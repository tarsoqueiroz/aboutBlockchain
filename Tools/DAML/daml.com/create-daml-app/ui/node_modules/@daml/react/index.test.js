"use strict";
// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// NOTE(MH): Unfortunately the `act` function triggers this warning by looking
// like a promise without being one.
/* eslint-disable @typescript-eslint/no-floating-promises */
var react_1 = __importStar(require("react"));
var react_hooks_1 = require("@testing-library/react-hooks");
var index_1 = __importStar(require("./index"));
var events_1 = require("events");
var mockConstructor = jest.fn();
var mockQuery = jest.fn();
var mockFetchByKey = jest.fn();
var mockStreamQuery = jest.fn();
var mockStreamFetchByKey = jest.fn();
var mockFunctions = [mockConstructor, mockQuery, mockFetchByKey, mockStreamQuery, mockStreamFetchByKey];
jest.mock('@daml/ledger', function () { return /** @class */ (function () {
    function class_1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        mockConstructor.apply(void 0, args);
    }
    class_1.prototype.query = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return mockQuery.apply(void 0, args);
    };
    class_1.prototype.fetchByKey = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return mockFetchByKey.apply(void 0, args);
    };
    class_1.prototype.streamQuery = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return mockStreamQuery.apply(void 0, args);
    };
    class_1.prototype.streamFetchByKey = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return mockStreamFetchByKey.apply(void 0, args);
    };
    return class_1;
}()); });
/**
 * Returns a mock stream object using an `EventEmitter` to implement on, off functions.
 */
var mockStream = function () {
    var emitter = new events_1.EventEmitter();
    var stream = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        on: function (type, listener) { return void emitter.on(type, listener); },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        off: function (type, listener) { return void emitter.on(type, listener); },
        close: function () {
            emitter.removeAllListeners();
            console.log('mock stream closed');
        }
    };
    return [stream, emitter];
};
var TOKEN = 'test_token';
var PARTY = 'test_party';
function renderDamlHook(callback) {
    var wrapper = function (_a) {
        var children = _a.children;
        return react_1.default.createElement(index_1.default, { token: TOKEN, party: PARTY }, children);
    };
    return react_hooks_1.renderHook(callback, { wrapper: wrapper });
}
/**
 * Dummy template, needs at least the templateId field for debug messages emitted by
 * `useStreamQuery`.
 */
var Foo = { templateId: 'FooTemplateId' };
beforeEach(function () {
    mockFunctions.forEach(function (mock) { return mock.mockClear(); });
});
test('DamlLedger', function () {
    renderDamlHook(function () { return; });
    expect(mockConstructor).toHaveBeenCalledTimes(1);
    expect(mockConstructor).toHaveBeenLastCalledWith({ token: TOKEN, httpBaseUrl: undefined, wsBaseUrl: undefined });
});
test('useParty', function () {
    var result = renderDamlHook(function () { return index_1.useParty(); }).result;
    expect(result.current).toBe(PARTY);
});
describe('useQuery', function () {
    test('one shot without query', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolvent, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    resolvent = ['foo'];
                    mockQuery.mockReturnValueOnce(Promise.resolve(resolvent));
                    _a = renderDamlHook(function () { return index_1.useQuery(Foo); }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    expect(mockQuery).toHaveBeenCalledTimes(1);
                    expect(mockQuery).toHaveBeenLastCalledWith(Foo, undefined);
                    mockQuery.mockClear();
                    expect(result.current.contracts).toEqual([]);
                    expect(result.current.loading).toBe(true);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(mockQuery).not.toHaveBeenCalled();
                    expect(result.current.contracts).toBe(resolvent);
                    expect(result.current.loading).toBe(false);
                    return [2 /*return*/];
            }
        });
    }); });
    test('change to query', function () { return __awaiter(void 0, void 0, void 0, function () {
        var query1, query2, resolvent1, resolvent2, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    query1 = 'foo-query';
                    query2 = 'bar-query';
                    resolvent1 = ['foo'];
                    resolvent2 = ['bar'];
                    // First rendering works?
                    mockQuery.mockReturnValueOnce(Promise.resolve(resolvent1));
                    _a = renderDamlHook(function () {
                        var _a = react_1.useState(query1), query = _a[0], setQuery = _a[1];
                        var queryResult = index_1.useQuery(Foo, function () { return ({ query: query }); }, [query]);
                        return { queryResult: queryResult, query: query, setQuery: setQuery };
                    }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    expect(mockQuery).toHaveBeenCalledTimes(1);
                    expect(mockQuery).toHaveBeenLastCalledWith(Foo, { query: query1 });
                    mockQuery.mockClear();
                    expect(result.current.queryResult).toEqual({ contracts: [], loading: true });
                    expect(result.current.query).toBe(query1);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contracts: resolvent1, loading: false });
                    // Change to query triggers another call to JSON API?
                    mockQuery.mockReturnValueOnce(Promise.resolve(resolvent2));
                    react_hooks_1.act(function () { return result.current.setQuery(query2); });
                    expect(mockQuery).toHaveBeenCalledTimes(1);
                    expect(mockQuery).toHaveBeenLastCalledWith(Foo, { query: query2 });
                    mockQuery.mockClear();
                    expect(result.current.queryResult).toEqual({ contracts: [], loading: true });
                    expect(result.current.query).toBe(query2);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 2:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contracts: resolvent2, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
    test('rerendering without query change', function () { return __awaiter(void 0, void 0, void 0, function () {
        var query, resolvent, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    query = 'query';
                    resolvent = ['foo'];
                    // First rendering works?
                    mockQuery.mockReturnValueOnce(Promise.resolve(resolvent));
                    _a = renderDamlHook(function () {
                        var setState = react_1.useState('state')[1];
                        var queryResult = index_1.useQuery(Foo, function () { return ({ query: query }); }, [query]);
                        return { queryResult: queryResult, setState: setState };
                    }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    expect(mockQuery).toHaveBeenCalledTimes(1);
                    mockQuery.mockClear();
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contracts: resolvent, loading: false });
                    // Change to unrelated state does _not_ trigger another call to JSON API?
                    react_hooks_1.act(function () { return result.current.setState('new-state'); });
                    expect(mockQuery).not.toHaveBeenCalled();
                    expect(result.current.queryResult).toEqual({ contracts: resolvent, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
    test('useReload', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolvent1, resolvent2, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    resolvent1 = ['foo'];
                    resolvent2 = ['bar'];
                    mockQuery.mockReturnValueOnce(Promise.resolve(resolvent1));
                    _a = renderDamlHook(function () {
                        var reload = index_1.useReload();
                        var queryResult = index_1.useQuery(Foo);
                        return { reload: reload, queryResult: queryResult };
                    }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    // first query
                    expect(mockQuery).toHaveBeenCalledTimes(1);
                    expect(mockQuery).toHaveBeenLastCalledWith(Foo, undefined);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contracts: resolvent1, loading: false });
                    mockQuery.mockClear();
                    // query result changes
                    mockQuery.mockReturnValueOnce(Promise.resolve(resolvent2));
                    // user reloads
                    react_hooks_1.act(function () { return result.current.reload(); });
                    return [4 /*yield*/, waitForNextUpdate()];
                case 2:
                    _b.sent();
                    expect(mockQuery).toHaveBeenCalledTimes(1);
                    expect(mockQuery).toHaveBeenLastCalledWith(Foo, undefined);
                    expect(result.current.queryResult).toEqual({ contracts: resolvent2, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('useFetchByKey', function () {
    test('one shot', function () { return __awaiter(void 0, void 0, void 0, function () {
        var contract, key, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    contract = { owner: 'Alice' };
                    key = contract.owner;
                    mockFetchByKey.mockReturnValueOnce(Promise.resolve(contract));
                    _a = renderDamlHook(function () { return index_1.useFetchByKey(Foo, function () { return key; }, [key]); }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    expect(mockFetchByKey).toHaveBeenCalledTimes(1);
                    expect(mockFetchByKey).toHaveBeenLastCalledWith(Foo, key);
                    mockFetchByKey.mockClear();
                    expect(result.current).toEqual({ contract: null, loading: true });
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(mockFetchByKey).not.toHaveBeenCalled();
                    expect(result.current).toEqual({ contract: contract, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
    test('change to key', function () { return __awaiter(void 0, void 0, void 0, function () {
        var contract1, key1, contract2, key2, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    contract1 = { owner: 'Alice' };
                    key1 = contract1.owner;
                    contract2 = { owner: 'Bob' };
                    key2 = contract2.owner;
                    // First rendering works?
                    mockFetchByKey.mockReturnValueOnce(Promise.resolve(contract1));
                    _a = renderDamlHook(function () {
                        var _a = react_1.useState(key1), key = _a[0], setKey = _a[1];
                        var queryResult = index_1.useFetchByKey(Foo, function () { return key; }, [key]);
                        return { queryResult: queryResult, key: key, setKey: setKey };
                    }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    expect(mockFetchByKey).toHaveBeenCalledTimes(1);
                    expect(mockFetchByKey).toHaveBeenLastCalledWith(Foo, key1);
                    mockFetchByKey.mockClear();
                    expect(result.current.queryResult).toEqual({ contract: null, loading: true });
                    expect(result.current.key).toBe(key1);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contract: contract1, loading: false });
                    // Change to key triggers another call to JSON API?
                    mockFetchByKey.mockReturnValueOnce(Promise.resolve(contract2));
                    react_hooks_1.act(function () { return result.current.setKey(key2); });
                    expect(mockFetchByKey).toHaveBeenCalledTimes(1);
                    expect(mockFetchByKey).toHaveBeenLastCalledWith(Foo, key2);
                    mockFetchByKey.mockClear();
                    expect(result.current.queryResult).toEqual({ contract: null, loading: true });
                    expect(result.current.key).toBe(key2);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 2:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contract: contract2, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
    test('rerendering without key change', function () { return __awaiter(void 0, void 0, void 0, function () {
        var contract, key, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    contract = { owner: 'Alice' };
                    key = contract.owner;
                    // First rendering works?
                    mockFetchByKey.mockReturnValueOnce(Promise.resolve(contract));
                    _a = renderDamlHook(function () {
                        var setState = react_1.useState('state')[1];
                        var queryResult = index_1.useFetchByKey(Foo, function () { return key; }, [key]);
                        return { queryResult: queryResult, setState: setState };
                    }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    expect(mockFetchByKey).toHaveBeenCalledTimes(1);
                    mockFetchByKey.mockClear();
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(result.current.queryResult).toEqual({ contract: contract, loading: false });
                    // Change to unrelated state does _not_ trigger another call to JSON API?
                    react_hooks_1.act(function () { return result.current.setState('new-state'); });
                    expect(mockFetchByKey).not.toHaveBeenCalled();
                    expect(result.current.queryResult).toEqual({ contract: contract, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
    test('useReload', function () { return __awaiter(void 0, void 0, void 0, function () {
        var contract1, key1, contract2, _a, result, waitForNextUpdate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    contract1 = { owner: 'Alice' };
                    key1 = contract1.owner;
                    contract2 = { owner: 'Bob' };
                    mockFetchByKey.mockReturnValueOnce(Promise.resolve(contract1));
                    _a = renderDamlHook(function () {
                        var reload = index_1.useReload();
                        var fetchResult = index_1.useFetchByKey(Foo, function () { return key1; }, [key1]);
                        return { reload: reload, fetchResult: fetchResult };
                    }), result = _a.result, waitForNextUpdate = _a.waitForNextUpdate;
                    // first fetchByKey
                    expect(mockFetchByKey).toHaveBeenCalledTimes(1);
                    expect(mockFetchByKey).toHaveBeenLastCalledWith(Foo, key1);
                    return [4 /*yield*/, waitForNextUpdate()];
                case 1:
                    _b.sent();
                    expect(result.current.fetchResult).toEqual({ contract: contract1, loading: false });
                    mockFetchByKey.mockClear();
                    //  fetchByKey result changes
                    mockFetchByKey.mockReturnValueOnce(Promise.resolve(contract2));
                    // user reloads
                    react_hooks_1.act(function () { return result.current.reload(); });
                    return [4 /*yield*/, waitForNextUpdate()];
                case 2:
                    _b.sent();
                    expect(mockFetchByKey).toHaveBeenCalledTimes(1);
                    expect(mockFetchByKey).toHaveBeenLastCalledWith(Foo, key1);
                    expect(result.current.fetchResult).toEqual({ contract: contract2, loading: false });
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('useStreamQuery', function () {
    test('live event changes loading status', function () {
        // setup
        var query = 'foo-query';
        var _a = mockStream(), stream = _a[0], emitter = _a[1];
        mockStreamQuery.mockReturnValueOnce(stream);
        var hookResult = renderDamlHook(function () { return index_1.useStreamQuery(Foo, function () { return ({ query: query }); }, [query]); });
        expect(mockStreamQuery).toHaveBeenCalledTimes(1);
        expect(mockStreamQuery).toHaveBeenLastCalledWith(Foo, { query: query });
        // no events have been emitted.
        expect(hookResult.result.current).toEqual({ contracts: [], loading: true });
        // live event
        react_hooks_1.act(function () {
            return void emitter.emit('live', []);
        });
        expect(hookResult.result.current).toEqual({ contracts: [], loading: false });
    });
    test('live event changes loading status', function () {
        // setup
        var query = 'foo-query';
        var _a = mockStream(), stream = _a[0], emitter = _a[1];
        mockStreamQuery.mockReturnValueOnce(stream);
        var hookResult = renderDamlHook(function () { return index_1.useStreamQuery(Foo, function () { return ({ query: query }); }, [query]); });
        expect(mockStreamQuery).toHaveBeenCalledTimes(1);
        expect(mockStreamQuery).toHaveBeenLastCalledWith(Foo, { query: query });
        // no events have been emitted.
        expect(hookResult.result.current).toEqual({ contracts: [], loading: true });
        // live event
        react_hooks_1.act(function () {
            return void emitter.emit('live', []);
        });
        expect(hookResult.result.current).toEqual({ contracts: [], loading: false });
    });
    test('empty stream', function () {
        // setup
        var query = 'foo-query';
        var _a = mockStream(), stream = _a[0], emitter = _a[1];
        mockStreamQuery.mockReturnValueOnce(stream);
        var hookResult = renderDamlHook(function () { return index_1.useStreamQuery(Foo, function () { return ({ query: query }); }, [query]); });
        expect(mockStreamQuery).toHaveBeenCalledTimes(1);
        expect(mockStreamQuery).toHaveBeenLastCalledWith(Foo, { query: query });
        // live event
        react_hooks_1.act(function () {
            return void emitter.emit('live', []);
        });
        // no events have been emitted.
        expect(hookResult.result.current).toEqual({ contracts: [], loading: false });
        // empty events
        react_hooks_1.act(function () {
            return void emitter.emit('change', []);
        });
        expect(hookResult.result.current).toEqual({ contracts: [], loading: false });
    });
    test('new events', function () {
        // setup
        var query = 'foo-query';
        var _a = mockStream(), stream = _a[0], emitter = _a[1];
        mockStreamQuery.mockReturnValueOnce(stream);
        var hookResult = renderDamlHook(function () { return index_1.useStreamQuery(Foo, function () { return ({ query: query }); }, [query]); });
        expect(mockStreamQuery).toHaveBeenCalledTimes(1);
        expect(mockStreamQuery).toHaveBeenLastCalledWith(Foo, { query: query });
        expect(hookResult.result.current.contracts).toEqual([]);
        // live event
        react_hooks_1.act(function () {
            return void emitter.emit('live', []);
        });
        expect(hookResult.result.current.loading).toBe(false);
        // one new event
        react_hooks_1.act(function () { return void emitter.emit('change', ['event1']); });
        expect(hookResult.result.current.contracts).toEqual(['event1']);
        expect(hookResult.result.current.loading).toBe(false);
        // two new events replacing old one.
        react_hooks_1.act(function () { return void emitter.emit('change', ['event2', 'event3']); });
        expect(hookResult.result.current).toEqual({ contracts: ['event2', 'event3'], loading: false });
    });
    test('changed query triggers reload', function () {
        // setup
        var query1 = 'foo-query';
        var query2 = 'bar-query';
        var _a = mockStream(), stream = _a[0], emitter = _a[1];
        mockStreamQuery.mockReturnValueOnce(stream);
        var result = renderDamlHook(function () {
            var _a = react_1.useState(query1), query = _a[0], setQuery = _a[1];
            var queryResult = index_1.useStreamQuery(Foo, function () { return ({ query: query }); }, [query]);
            return { queryResult: queryResult, query: query, setQuery: setQuery };
        }).result;
        expect(mockStreamQuery).toHaveBeenCalledTimes(1);
        expect(mockStreamQuery).toHaveBeenLastCalledWith(Foo, { query: query1 });
        // live event
        react_hooks_1.act(function () {
            return void emitter.emit('live', []);
        });
        expect(result.current.queryResult).toEqual({ contracts: [], loading: false });
        // new events
        react_hooks_1.act(function () { return void emitter.emit('change', ['foo']); });
        expect(result.current.queryResult).toEqual({ contracts: ['foo'], loading: false });
        // change query, expect stream to have been called with new query.
        mockStreamQuery.mockClear();
        mockStreamQuery.mockReturnValueOnce(stream);
        react_hooks_1.act(function () { return result.current.setQuery(query2); });
        // live event
        react_hooks_1.act(function () { return void emitter.emit('live', null); });
        // change event
        react_hooks_1.act(function () { return void emitter.emit('change', ['bar']); });
        expect(mockStreamQuery).toHaveBeenCalledTimes(1);
        expect(mockStreamQuery).toHaveBeenLastCalledWith(Foo, { query: query2 });
        expect(result.current.queryResult).toEqual({ contracts: ['bar'], loading: false });
    });
});
describe('useStreamFetchByKey', function () {
    test('empty stream', function () {
        var contract = { owner: 'Alice' };
        var key = contract.owner;
        var _a = mockStream(), stream = _a[0], emitter = _a[1];
        mockStreamFetchByKey.mockReturnValueOnce(stream);
        var result = renderDamlHook(function () { return index_1.useStreamFetchByKey(Foo, function () { return key; }, [key]); }).result;
        expect(mockStreamFetchByKey).toHaveBeenCalledTimes(1);
        expect(mockStreamFetchByKey).toHaveBeenLastCalledWith(Foo, key);
        expect(result.current).toEqual({ contract: null, loading: false });
        react_hooks_1.act(function () { return void emitter.emit('change', null); });
        expect(result.current).toEqual({ contract: null, loading: false });
    }),
        test('new event', function () {
            var contract = { owner: 'Alice' };
            var key = contract.owner;
            var _a = mockStream(), stream = _a[0], emitter = _a[1];
            mockStreamFetchByKey.mockReturnValueOnce(stream);
            var result = renderDamlHook(function () { return index_1.useStreamFetchByKey(Foo, function () { return key; }, [key]); }).result;
            expect(mockStreamFetchByKey).toHaveBeenCalledTimes(1);
            expect(mockStreamFetchByKey).toHaveBeenLastCalledWith(Foo, key);
            expect(result.current).toEqual({ contract: null, loading: false });
            react_hooks_1.act(function () { return void emitter.emit('change', contract); });
            expect(result.current).toEqual({ contract: contract, loading: false });
        }),
        test('changed key triggers reload', function () {
            var contract = { k1: 'Alice', k2: 'Bob' };
            var key1 = contract.k1;
            var key2 = contract.k2;
            var _a = mockStream(), stream = _a[0], emitter = _a[1];
            mockStreamFetchByKey.mockReturnValueOnce(stream);
            var result = renderDamlHook(function () {
                var _a = react_1.useState(key1), key = _a[0], setKey = _a[1];
                var fetchResult = index_1.useStreamFetchByKey(Foo, function () { return key; }, [key]);
                return { fetchResult: fetchResult, key: key, setKey: setKey };
            }).result;
            react_hooks_1.act(function () { return void emitter.emit('change', contract); });
            expect(mockStreamFetchByKey).toHaveBeenCalledTimes(1);
            expect(mockStreamFetchByKey).toHaveBeenLastCalledWith(Foo, key1);
            expect(result.current.fetchResult).toEqual({ contract: contract, loading: false });
            mockStreamFetchByKey.mockClear();
            mockStreamFetchByKey.mockReturnValueOnce(stream);
            react_hooks_1.act(function () { return result.current.setKey(key2); });
            expect(mockStreamFetchByKey).toHaveBeenCalledTimes(1);
            expect(mockStreamFetchByKey).toHaveBeenLastCalledWith(Foo, key2);
        });
    describe('createLedgerContext', function () {
        test('contexts can nest', function () {
            var innerLedger = index_1.createLedgerContext();
            var innerTOKEN = "inner_TOKEN";
            var innerPARTY = "inner_PARTY";
            var outerLedger = index_1.createLedgerContext('Outer');
            var outerTOKEN = "outer_TOKEN";
            var outerPARTY = "outer_PARTY";
            var innerWrapper = function (_a) {
                var children = _a.children;
                return react_1.default.createElement(innerLedger.DamlLedger, { token: innerTOKEN, party: innerPARTY }, children);
            };
            var r1 = react_hooks_1.renderHook(function () { return innerLedger.useParty(); }, { wrapper: innerWrapper });
            expect(r1.result.current).toBe(innerPARTY);
            var outerWrapper = function (_a) {
                var children = _a.children;
                return react_1.default.createElement(outerLedger.DamlLedger, { token: outerTOKEN, party: outerPARTY }, innerWrapper({ children: children }));
            };
            var r2 = react_hooks_1.renderHook(function () { return outerLedger.useParty(); }, { wrapper: outerWrapper });
            expect(r2.result.current).toBe(outerPARTY);
            var r3 = react_hooks_1.renderHook(function () { return innerLedger.useParty(); }, { wrapper: outerWrapper });
            expect(r3.result.current).toBe(innerPARTY);
        });
    });
});
//# sourceMappingURL=index.test.js.map