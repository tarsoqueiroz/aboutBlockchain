import { Choice, ContractId, List, Party, Template, Text } from '@daml/types';
/**
 * A newly created contract.
 *
 * @typeparam T The contract template type.
 * @typeparam K The contract key type.
 * @typeparam I The contract id type.
 *
 */
export declare type CreateEvent<T extends object, K = unknown, I extends string = string> = {
    templateId: I;
    contractId: ContractId<T>;
    signatories: List<Party>;
    observers: List<Party>;
    agreementText: Text;
    key: K;
    payload: T;
};
/**
 * An archived contract.
 *
 * @typeparam T The contract template type.
 * @typeparam I The contract id type.
 */
export declare type ArchiveEvent<T extends object, I extends string = string> = {
    templateId: I;
    contractId: ContractId<T>;
};
/**
 * An event is either the creation or archival of a contract.
 *
 * @typeparam T The contract template type.
 * @typeparam K The contract key type.
 * @typeparam I The contract id type.
 */
export declare type Event<T extends object, K = unknown, I extends string = string> = {
    created: CreateEvent<T, K, I>;
} | {
    archived: ArchiveEvent<T, I>;
};
/**
 * `Query<T>` is the type of queries for searching for contracts of template type `T`.
 *
 * `Query<T>` is an object consisting of a subset of the fields of `T`.
 *
 * Comparison queries are not yet supported.
 *
 * NB: This type is heavily related to the `DeepPartial` type that can be found
 * in the TypeScript community.
 *
 * @typeparam T The contract template type.
 *
 */
export declare type Query<T> = T extends object ? {
    [K in keyof T]?: Query<T[K]>;
} : T;
/**
 * Event emitted when a stream gets closed.
 */
export declare type StreamCloseEvent = {
    code: number;
    reason: string;
};
/**
 * Interface for streams returned by the streaming methods of the `Ledger`
 * class. Each `'change'` event contains accumulated state of type `State` as
 * well as the ledger events that triggered the current state change.
 *
 * @typeparam T The contract template type.
 * @typeparam K The contract key type.
 * @typeparam I The contract id type.
 * @typeparam State The accumulated state.
 */
export interface Stream<T extends object, K, I extends string, State> {
    on(type: 'live', listener: (state: State) => void): void;
    on(type: 'change', listener: (state: State, events: readonly Event<T, K, I>[]) => void): void;
    on(type: 'close', listener: (closeEvent: StreamCloseEvent) => void): void;
    off(type: 'live', listener: (state: State) => void): void;
    off(type: 'change', listener: (state: State, events: readonly Event<T, K, I>[]) => void): void;
    off(type: 'close', listener: (closeEvent: StreamCloseEvent) => void): void;
    close(): void;
}
/**
 * Options for creating a handle to a DAML ledger.
 */
declare type LedgerOptions = {
    /** JSON web token used for authentication. */
    token: string;
    /**
     * Optional base URL for the non-streaming endpoints of the JSON API. If this parameter is not
     * provided, the protocol, host and port of the `window.location` object are used.
     */
    httpBaseUrl?: string;
    /**
     * Optional base URL for the streaming endpoints of the JSON API. If this parameter is not
     * provided, the base URL for the non-streaming endpoints is used with the protocol 'http' or
     * 'https' replaced by 'ws' or 'wss', respectively.  Specifying this parameter explicitly can be
     * useful when the non-streaming requests are proxied but the streaming request cannot be proxied,
     * as it is the case with the development server of `create-react-app`.
     */
    wsBaseUrl?: string;
    /**
     * Optional number of milliseconds a connection has to be live to be considered healthy. If the
     * connection is closed after being live for at least this amount of time, the `Ledger` tries to
     * reconnect, else not.
     */
    reconnectThreshold?: number;
};
/**
 * An object of type `Ledger` represents a handle to a DAML ledger.
 */
declare class Ledger {
    private readonly token;
    private readonly httpBaseUrl;
    private readonly wsBaseUrl;
    private readonly reconnectThreshold;
    /**
     * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.
     */
    constructor({ token, httpBaseUrl, wsBaseUrl, reconnectThreshold }: LedgerOptions);
    /**
     * @internal
     *
     * Internal function to submit a command to the JSON API.
     */
    private submit;
    /**
     * Retrieve contracts for a given template.
     *
     * When no `query` argument is given, all contracts visible to the submitting party are returned.
     * When a `query` argument is given, only those contracts matching the query are returned. See
     * https://docs.daml.com/json-api/search-query-language.html for a description of the query
     * language.
     *
     * @param template The contract template of the contracts to be matched against.
     * @param query The contract query for the contracts to be matched against.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     *
     */
    query<T extends object, K, I extends string>(template: Template<T, K, I>, query?: Query<T>): Promise<CreateEvent<T, K, I>[]>;
    /**
     * Fetch a contract identified by its contract ID.
     *
     * @param template The template of the contract to be fetched.
     * @param contractId The contract id of the contract to be fetched.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     *
     */
    fetch<T extends object, K, I extends string>(template: Template<T, K, I>, contractId: ContractId<T>): Promise<CreateEvent<T, K, I> | null>;
    /**
     * Fetch a contract identified by its contract key.
     *
     * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of
     * its contract id.
     *
     * @param template The template of the contract to be fetched.
     * @param key The contract key of the contract to be fetched.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     */
    fetchByKey<T extends object, K, I extends string>(template: Template<T, K, I>, key: K): Promise<CreateEvent<T, K, I> | null>;
    /**
     * Create a contract for a given template.
     *
     * @param template The template of the contract to be created.
     * @param payload The template arguments for the contract to be created.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     *
     */
    create<T extends object, K, I extends string>(template: Template<T, K, I>, payload: T): Promise<CreateEvent<T, K, I>>;
    /**
     * Exercise a choice on a contract identified by its contract ID.
     *
     * @param choice The choice to exercise.
     * @param contractId The contract id of the contract to exercise.
     * @param argument The choice arguments.
     *
     * @typeparam T The contract template type.
     * @typeparam C The type of the contract choice.
     * @typeparam R The return type of the choice.
     *
     * @returns The return value of the choice together with a list of [[event]]'s that where created
     * as a result of exercising the choice.
     */
    exercise<T extends object, C, R>(choice: Choice<T, C, R>, contractId: ContractId<T>, argument: C): Promise<[R, Event<object>[]]>;
    /**
     * Exercise a choice on a contract identified by its contract key.
     *
     * Same as [[exercise]], but the contract is identified by its contract key instead of its
     * contract id.
     *
     * @param choice The choice to exercise.
     * @param contractId The contract id of the contract to exercise.
     * @param argument The choice arguments.
     *
     * @typeparam T The contract template type.
     * @typeparam C The type of the contract choice.
     * @typeparam R The return type of the choice.
     * @typeparam K The type of the contract key.
     *
     * @returns The return value of the choice together with a list of [[event]]'s that where created
     * as a result of exercising the choice.
     */
    exerciseByKey<T extends object, C, R, K>(choice: Choice<T, C, R, K>, key: K, argument: C): Promise<[R, Event<object>[]]>;
    /**
     * Archive a contract identified by its contract ID.
     *
     * @param template The template of the contract to archive.
     * @param contractId The contract id of the contract to archive.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     *
     */
    archive<T extends object, K, I extends string>(template: Template<T, K, I>, contractId: ContractId<T>): Promise<ArchiveEvent<T, I>>;
    /**
     * Archive a contract identified by its contract key.
     * Same as [[archive]], but the contract to be archived is identified by its contract key.
     *
     * @param template The template of the contract to be archived.
     * @param key The contract key of the contract to be archived.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     *
     */
    archiveByKey<T extends object, K, I extends string>(template: Template<T, K, I>, key: K): Promise<ArchiveEvent<T, I>>;
    /**
     * @internal
     *
     * Internal command to submit a request to a streaming endpoint of the
     * JSON API. Returns a stream consisting of accumulated state together with
     * the events that produced the latest state change. The `change` function
     * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,
     * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we
     * must have the structural equalities
     * ```
     * change(s, []) == s
     * change(s, x.concat(y)) == change(change(s, x), y)
     * ```
     * Also, `change` must never change its arguments.
     */
    private streamSubmit;
    /**
     * Retrieve a consolidated stream of events for a given template and query.
     *
     * The accumulated state is the current set of active contracts matching the query. When no
     * `query` argument is given, all events visible to the submitting party are returned. When a
     * `query` argument is given, only those create events matching the query are returned. See
     * https://docs.daml.com/json-api/search-query-language.html for a description of the query
     * language.
     *
     * @param template The contract template to match contracts against.
     * @param query The query to match contracts agains.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     */
    streamQuery<T extends object, K, I extends string>(template: Template<T, K, I>, query?: Query<T>): Stream<T, K, I, readonly CreateEvent<T, K, I>[]>;
    /**
     * Retrieve a consolidated stream of events for a given template and contract key.
     *
     * Same as [[streamQuery]], but instead of a query, match contracts by contract key.
     *
     * @typeparam T The contract template type.
     * @typeparam K The contract key type.
     * @typeparam I The contract id type.
     */
    streamFetchByKey<T extends object, K, I extends string>(template: Template<T, K, I>, key: K): Stream<T, K, I, CreateEvent<T, K, I> | null>;
}
export default Ledger;
